# This file is autogenerated. Please change the generator code instead.
# Copyright (c) 2022 - Chris Watson and contributors
# Licensed under the MIT License. See the LICENSE file for details.

class Telegram::API
    # Use this method to receive incoming updates using long polling (wiki). An Array of Update objects is
    # returned.
    def get_updates(
      offset : Int32? = nil,
      limit : Int32? = nil,
      timeout : Int32? = nil,
      allowed_updates : Array(String)? = nil,
    )
      request(Array(Update), "getUpdates", {
        offset: offset,
        limit: limit,
        timeout: timeout,
        allowed_updates: allowed_updates,
      })
    end

    # Use this method to specify a url and receive incoming updates via an outgoing webhook. Whenever there is an
    # update for the bot, we will send an HTTPS POST request to the specified url, containing a JSON-serialized
    # Update. In case of an unsuccessful request, we will give up after a reasonable amount of attempts. Returns
    # True on success. If you'd like to make sure that the Webhook request comes from Telegram, we recommend using
    # a secret path in the URL, e.g. https://www.example.com/<token>. Since nobody else knows your bot's
    # token, you can be pretty sure it's us.
    def set_webhook(
      url : String,
      certificate : InputFile? = nil,
      ip_address : String? = nil,
      max_connections : Int32? = nil,
      drop_pending_updates : Bool? = nil,
      allowed_updates : Array(String)? = nil,
    )
      request(Bool, "setWebhook", {
        url: url,
        certificate: certificate,
        ip_address: ip_address,
        max_connections: max_connections,
        allowed_updates: allowed_updates,
        drop_pending_updates: drop_pending_updates,
      })
    end

    # Use this method to remove webhook integration if you decide to switch back to getUpdates. Returns True on
    # success.
    def delete_webhook(
      drop_pending_updates : Bool? = nil,
    )
      request(Bool, "deleteWebhook", {
        drop_pending_updates: drop_pending_updates,
      })
    end

    # Use this method to get current webhook status. Requires no parameters. On success, returns a WebhookInfo
    # object. If the bot is using getUpdates, will return an object with the url field empty.
    def get_webhook_info
      request(WebhookInfo, "getWebhookInfo")
    end

    # A simple method for testing your bot's authentication token. Requires no parameters. Returns basic
    # information about the bot in form of a User object.
    def get_me
      request(User, "getMe")
    end

    # Use this method to log out from the cloud Bot API server before launching the bot locally. You must log out the
    # bot before running it locally, otherwise there is no guarantee that the bot will receive updates. After a
    # successful call, you can immediately log in on a local server, but will not be able to log in back to the cloud
    # Bot API server for 10 minutes. Returns True on success. Requires no parameters.
    def log_out
      request(Bool, "logOut")
    end

    # Use this method to close the bot instance before moving it from one local server to another. You need to
    # delete the webhook before calling this method to ensure that the bot isn't launched again after server
    # restart. The method will return error 429 in the first 10 minutes after the bot is launched. Returns True on
    # success. Requires no parameters.
    def close
      request(Bool, "close")
    end

    # Use this method to send text messages. On success, the sent Message is returned.
    def send_message(
      chat_id : (Int64 | String),
      text : String,
      parse_mode : ParseMode? = nil,
      disable_web_page_preview : Bool? = nil,
      disable_notification : Bool? = nil,
      protect_content : Bool? = nil,
      reply_to_message_id : Int32? = nil,
      allow_sending_without_reply : Bool? = nil,
      reply_markup : (InlineKeyboardMarkup | ReplyKeyboardMarkup | ReplyKeyboardRemove | ForceReply)? = nil,
      entities : Array(MessageEntity)? = nil,
    )
      request(Message, "sendMessage", {
        chat_id: chat_id,
        text: text,
        parse_mode: parse_mode,
        entities: entities,
        disable_web_page_preview: disable_web_page_preview,
        disable_notification: disable_notification,
        protect_content: protect_content,
        reply_to_message_id: reply_to_message_id,
        allow_sending_without_reply: allow_sending_without_reply,
        reply_markup: reply_markup,
      })
    end

    # Use this method to forward messages of any kind. Service messages can't be forwarded. On success, the sent
    # Message is returned.
    def forward_message(
      chat_id : (Int64 | String),
      from_chat_id : (Int32 | String),
      message_id : Int32,
      disable_notification : Bool? = nil,
      protect_content : Bool? = nil,
    )
      request(Message, "forwardMessage", {
        chat_id: chat_id,
        from_chat_id: from_chat_id,
        disable_notification: disable_notification,
        protect_content: protect_content,
        message_id: message_id,
      })
    end

    # Use this method to copy messages of any kind. Service messages and invoice messages can't be copied. The
    # method is analogous to the method forwardMessage, but the copied message doesn't have a link to the
    # original message. Returns the MessageId of the sent message on success.
    def copy_message(
      chat_id : (Int64 | String),
      from_chat_id : (Int32 | String),
      message_id : Int32,
      caption : String? = nil,
      parse_mode : ParseMode? = nil,
      disable_notification : Bool? = nil,
      protect_content : Bool? = nil,
      reply_to_message_id : Int32? = nil,
      allow_sending_without_reply : Bool? = nil,
      reply_markup : (InlineKeyboardMarkup | ReplyKeyboardMarkup | ReplyKeyboardRemove | ForceReply)? = nil,
      caption_entities : Array(MessageEntity)? = nil,
    )
      request(MessageId, "copyMessage", {
        chat_id: chat_id,
        from_chat_id: from_chat_id,
        message_id: message_id,
        caption: caption,
        parse_mode: parse_mode,
        caption_entities: caption_entities,
        disable_notification: disable_notification,
        protect_content: protect_content,
        reply_to_message_id: reply_to_message_id,
        allow_sending_without_reply: allow_sending_without_reply,
        reply_markup: reply_markup,
      })
    end

    # Use this method to send photos. On success, the sent Message is returned.
    def send_photo(
      chat_id : (Int64 | String),
      photo : (InputFile | String),
      caption : String? = nil,
      parse_mode : ParseMode? = nil,
      disable_notification : Bool? = nil,
      protect_content : Bool? = nil,
      reply_to_message_id : Int32? = nil,
      allow_sending_without_reply : Bool? = nil,
      reply_markup : (InlineKeyboardMarkup | ReplyKeyboardMarkup | ReplyKeyboardRemove | ForceReply)? = nil,
      caption_entities : Array(MessageEntity)? = nil,
    )
      request(Message, "sendPhoto", {
        chat_id: chat_id,
        photo: photo,
        caption: caption,
        parse_mode: parse_mode,
        caption_entities: caption_entities,
        disable_notification: disable_notification,
        protect_content: protect_content,
        reply_to_message_id: reply_to_message_id,
        allow_sending_without_reply: allow_sending_without_reply,
        reply_markup: reply_markup,
      })
    end

    # Use this method to send audio files, if you want Telegram clients to display them in the music player. Your
    # audio must be in the .MP3 or .M4A format. On success, the sent Message is returned. Bots can currently send
    # audio files of up to 50 MB in size, this limit may be changed in the future. For sending voice messages, use the
    # sendVoice method instead.
    def send_audio(
      chat_id : (Int64 | String),
      audio : (InputFile | String),
      caption : String? = nil,
      parse_mode : ParseMode? = nil,
      duration : Int32? = nil,
      performer : String? = nil,
      title : String? = nil,
      thumb : (InputFile | String)? = nil,
      disable_notification : Bool? = nil,
      protect_content : Bool? = nil,
      reply_to_message_id : Int32? = nil,
      allow_sending_without_reply : Bool? = nil,
      reply_markup : (InlineKeyboardMarkup | ReplyKeyboardMarkup | ReplyKeyboardRemove | ForceReply)? = nil,
      caption_entities : Array(MessageEntity)? = nil,
    )
      request(Message, "sendAudio", {
        chat_id: chat_id,
        audio: audio,
        caption: caption,
        parse_mode: parse_mode,
        caption_entities: caption_entities,
        duration: duration,
        performer: performer,
        title: title,
        thumb: thumb,
        disable_notification: disable_notification,
        protect_content: protect_content,
        reply_to_message_id: reply_to_message_id,
        allow_sending_without_reply: allow_sending_without_reply,
        reply_markup: reply_markup,
      })
    end

    # Use this method to send general files. On success, the sent Message is returned. Bots can currently send
    # files of any type of up to 50 MB in size, this limit may be changed in the future.
    def send_document(
      chat_id : (Int64 | String),
      document : (InputFile | String),
      thumb : (InputFile | String)? = nil,
      caption : String? = nil,
      parse_mode : ParseMode? = nil,
      disable_content_type_detection : Bool? = nil,
      disable_notification : Bool? = nil,
      protect_content : Bool? = nil,
      reply_to_message_id : Int32? = nil,
      allow_sending_without_reply : Bool? = nil,
      reply_markup : (InlineKeyboardMarkup | ReplyKeyboardMarkup | ReplyKeyboardRemove | ForceReply)? = nil,
      caption_entities : Array(MessageEntity)? = nil,
    )
      request(Message, "sendDocument", {
        chat_id: chat_id,
        document: document,
        thumb: thumb,
        caption: caption,
        parse_mode: parse_mode,
        caption_entities: caption_entities,
        disable_content_type_detection: disable_content_type_detection,
        disable_notification: disable_notification,
        protect_content: protect_content,
        reply_to_message_id: reply_to_message_id,
        allow_sending_without_reply: allow_sending_without_reply,
        reply_markup: reply_markup,
      })
    end

    # Use this method to send video files, Telegram clients support mp4 videos (other formats may be sent as
    # Document). On success, the sent Message is returned. Bots can currently send video files of up to 50 MB in
    # size, this limit may be changed in the future.
    def send_video(
      chat_id : (Int64 | String),
      video : (InputFile | String),
      duration : Int32? = nil,
      width : Int32? = nil,
      height : Int32? = nil,
      thumb : (InputFile | String)? = nil,
      caption : String? = nil,
      parse_mode : ParseMode? = nil,
      supports_streaming : Bool? = nil,
      disable_notification : Bool? = nil,
      protect_content : Bool? = nil,
      reply_to_message_id : Int32? = nil,
      allow_sending_without_reply : Bool? = nil,
      reply_markup : (InlineKeyboardMarkup | ReplyKeyboardMarkup | ReplyKeyboardRemove | ForceReply)? = nil,
      caption_entities : Array(MessageEntity)? = nil,
    )
      request(Message, "sendVideo", {
        chat_id: chat_id,
        video: video,
        duration: duration,
        width: width,
        height: height,
        thumb: thumb,
        caption: caption,
        parse_mode: parse_mode,
        caption_entities: caption_entities,
        supports_streaming: supports_streaming,
        disable_notification: disable_notification,
        protect_content: protect_content,
        reply_to_message_id: reply_to_message_id,
        allow_sending_without_reply: allow_sending_without_reply,
        reply_markup: reply_markup,
      })
    end

    # Use this method to send animation files (GIF or H.264/MPEG-4 AVC video without sound). On success, the sent
    # Message is returned. Bots can currently send animation files of up to 50 MB in size, this limit may be changed
    # in the future.
    def send_animation(
      chat_id : (Int64 | String),
      animation : (InputFile | String),
      duration : Int32? = nil,
      width : Int32? = nil,
      height : Int32? = nil,
      thumb : (InputFile | String)? = nil,
      caption : String? = nil,
      parse_mode : ParseMode? = nil,
      disable_notification : Bool? = nil,
      protect_content : Bool? = nil,
      reply_to_message_id : Int32? = nil,
      allow_sending_without_reply : Bool? = nil,
      reply_markup : (InlineKeyboardMarkup | ReplyKeyboardMarkup | ReplyKeyboardRemove | ForceReply)? = nil,
      caption_entities : Array(MessageEntity)? = nil,
    )
      request(Message, "sendAnimation", {
        chat_id: chat_id,
        animation: animation,
        duration: duration,
        width: width,
        height: height,
        thumb: thumb,
        caption: caption,
        parse_mode: parse_mode,
        caption_entities: caption_entities,
        disable_notification: disable_notification,
        protect_content: protect_content,
        reply_to_message_id: reply_to_message_id,
        allow_sending_without_reply: allow_sending_without_reply,
        reply_markup: reply_markup,
      })
    end

    # Use this method to send audio files, if you want Telegram clients to display the file as a playable voice
    # message. For this to work, your audio must be in an .OGG file encoded with OPUS (other formats may be sent as
    # Audio or Document). On success, the sent Message is returned. Bots can currently send voice messages of up
    # to 50 MB in size, this limit may be changed in the future.
    def send_voice(
      chat_id : (Int64 | String),
      voice : (InputFile | String),
      caption : String? = nil,
      parse_mode : ParseMode? = nil,
      duration : Int32? = nil,
      disable_notification : Bool? = nil,
      protect_content : Bool? = nil,
      reply_to_message_id : Int32? = nil,
      allow_sending_without_reply : Bool? = nil,
      reply_markup : (InlineKeyboardMarkup | ReplyKeyboardMarkup | ReplyKeyboardRemove | ForceReply)? = nil,
      caption_entities : Array(MessageEntity)? = nil,
    )
      request(Message, "sendVoice", {
        chat_id: chat_id,
        voice: voice,
        caption: caption,
        parse_mode: parse_mode,
        caption_entities: caption_entities,
        duration: duration,
        disable_notification: disable_notification,
        protect_content: protect_content,
        reply_to_message_id: reply_to_message_id,
        allow_sending_without_reply: allow_sending_without_reply,
        reply_markup: reply_markup,
      })
    end

    # As of v.4.0, Telegram clients support rounded square mp4 videos of up to 1 minute long. Use this method to
    # send video messages. On success, the sent Message is returned.
    def send_video_note(
      chat_id : (Int64 | String),
      video_note : (InputFile | String),
      duration : Int32? = nil,
      length : Int32? = nil,
      thumb : (InputFile | String)? = nil,
      disable_notification : Bool? = nil,
      protect_content : Bool? = nil,
      reply_to_message_id : Int32? = nil,
      allow_sending_without_reply : Bool? = nil,
      reply_markup : (InlineKeyboardMarkup | ReplyKeyboardMarkup | ReplyKeyboardRemove | ForceReply)? = nil,
    )
      request(Message, "sendVideoNote", {
        chat_id: chat_id,
        video_note: video_note,
        duration: duration,
        length: length,
        thumb: thumb,
        disable_notification: disable_notification,
        protect_content: protect_content,
        reply_to_message_id: reply_to_message_id,
        allow_sending_without_reply: allow_sending_without_reply,
        reply_markup: reply_markup,
      })
    end

    # Use this method to send a group of photos, videos, documents or audios as an album. Documents and audio files
    # can be only grouped in an album with messages of the same type. On success, an array of Messages that were sent
    # is returned.
    def send_media_group(
      chat_id : (Int64 | String),
      media : (Array(InputMediaAudio) | Array(InputMediaDocument) | Array(InputMediaPhoto) | Array(InputMediaVideo)),
      disable_notification : Bool? = nil,
      protect_content : Bool? = nil,
      reply_to_message_id : Int32? = nil,
      allow_sending_without_reply : Bool? = nil,
    )
      request(Array(Message), "sendMediaGroup", {
        chat_id: chat_id,
        media: media,
        disable_notification: disable_notification,
        protect_content: protect_content,
        reply_to_message_id: reply_to_message_id,
        allow_sending_without_reply: allow_sending_without_reply,
      })
    end

    # Use this method to send point on the map. On success, the sent Message is returned.
    def send_location(
      chat_id : (Int64 | String),
      latitude : Float64,
      longitude : Float64,
      horizontal_accuracy : Float64? = nil,
      live_period : Int32? = nil,
      heading : Int32? = nil,
      proximity_alert_radius : Int32? = nil,
      disable_notification : Bool? = nil,
      protect_content : Bool? = nil,
      reply_to_message_id : Int32? = nil,
      allow_sending_without_reply : Bool? = nil,
      reply_markup : (InlineKeyboardMarkup | ReplyKeyboardMarkup | ReplyKeyboardRemove | ForceReply)? = nil,
    )
      request(Message, "sendLocation", {
        chat_id: chat_id,
        latitude: latitude,
        longitude: longitude,
        horizontal_accuracy: horizontal_accuracy,
        live_period: live_period,
        heading: heading,
        proximity_alert_radius: proximity_alert_radius,
        disable_notification: disable_notification,
        protect_content: protect_content,
        reply_to_message_id: reply_to_message_id,
        allow_sending_without_reply: allow_sending_without_reply,
        reply_markup: reply_markup,
      })
    end

    # Use this method to edit live location messages. A location can be edited until its live_period expires or
    # editing is explicitly disabled by a call to stopMessageLiveLocation. On success, if the edited message is
    # not an inline message, the edited Message is returned, otherwise True is returned.
    def edit_message_live_location(
      latitude : Float64,
      longitude : Float64,
      chat_id : (Int64 | String)? = nil,
      message_id : Int32? = nil,
      inline_message_id : String? = nil,
      horizontal_accuracy : Float64? = nil,
      heading : Int32? = nil,
      proximity_alert_radius : Int32? = nil,
      reply_markup : InlineKeyboardMarkup? = nil,
    )
      request((Message | Bool), "editMessageLiveLocation", {
        chat_id: chat_id,
        message_id: message_id,
        inline_message_id: inline_message_id,
        latitude: latitude,
        longitude: longitude,
        horizontal_accuracy: horizontal_accuracy,
        heading: heading,
        proximity_alert_radius: proximity_alert_radius,
        reply_markup: reply_markup,
      })
    end

    # Use this method to stop updating a live location message before live_period expires. On success, if the
    # message is not an inline message, the edited Message is returned, otherwise True is returned.
    def stop_message_live_location(
      chat_id : (Int64 | String)? = nil,
      message_id : Int32? = nil,
      inline_message_id : String? = nil,
      reply_markup : InlineKeyboardMarkup? = nil,
    )
      request((Message | Bool), "stopMessageLiveLocation", {
        chat_id: chat_id,
        message_id: message_id,
        inline_message_id: inline_message_id,
        reply_markup: reply_markup,
      })
    end

    # Use this method to send information about a venue. On success, the sent Message is returned.
    def send_venue(
      chat_id : (Int64 | String),
      latitude : Float64,
      longitude : Float64,
      title : String,
      address : String,
      foursquare_id : String? = nil,
      foursquare_type : String? = nil,
      google_place_id : String? = nil,
      google_place_type : String? = nil,
      disable_notification : Bool? = nil,
      protect_content : Bool? = nil,
      reply_to_message_id : Int32? = nil,
      allow_sending_without_reply : Bool? = nil,
      reply_markup : (InlineKeyboardMarkup | ReplyKeyboardMarkup | ReplyKeyboardRemove | ForceReply)? = nil,
    )
      request(Message, "sendVenue", {
        chat_id: chat_id,
        latitude: latitude,
        longitude: longitude,
        title: title,
        address: address,
        foursquare_id: foursquare_id,
        foursquare_type: foursquare_type,
        google_place_id: google_place_id,
        google_place_type: google_place_type,
        disable_notification: disable_notification,
        protect_content: protect_content,
        reply_to_message_id: reply_to_message_id,
        allow_sending_without_reply: allow_sending_without_reply,
        reply_markup: reply_markup,
      })
    end

    # Use this method to send phone contacts. On success, the sent Message is returned.
    def send_contact(
      chat_id : (Int64 | String),
      phone_number : String,
      first_name : String,
      last_name : String? = nil,
      vcard : String? = nil,
      disable_notification : Bool? = nil,
      protect_content : Bool? = nil,
      reply_to_message_id : Int32? = nil,
      allow_sending_without_reply : Bool? = nil,
      reply_markup : (InlineKeyboardMarkup | ReplyKeyboardMarkup | ReplyKeyboardRemove | ForceReply)? = nil,
    )
      request(Message, "sendContact", {
        chat_id: chat_id,
        phone_number: phone_number,
        first_name: first_name,
        last_name: last_name,
        vcard: vcard,
        disable_notification: disable_notification,
        protect_content: protect_content,
        reply_to_message_id: reply_to_message_id,
        allow_sending_without_reply: allow_sending_without_reply,
        reply_markup: reply_markup,
      })
    end

    # Use this method to send a native poll. On success, the sent Message is returned.
    def send_poll(
      chat_id : (Int64 | String),
      question : String,
      options : Array(String),
      is_anonymous : Bool? = nil,
      type : String? = nil,
      allows_multiple_answers : Bool? = nil,
      correct_option_id : Int32? = nil,
      explanation : String? = nil,
      explanation_parse_mode : String? = nil,
      open_period : Int32? = nil,
      close_date : Int32? = nil,
      is_closed : Bool? = nil,
      disable_notification : Bool? = nil,
      protect_content : Bool? = nil,
      reply_to_message_id : Int32? = nil,
      allow_sending_without_reply : Bool? = nil,
      reply_markup : (InlineKeyboardMarkup | ReplyKeyboardMarkup | ReplyKeyboardRemove | ForceReply)? = nil,
      explanation_entities : Array(MessageEntity)? = nil,
    )
      request(Message, "sendPoll", {
        chat_id: chat_id,
        question: question,
        options: options,
        is_anonymous: is_anonymous,
        type: type,
        allows_multiple_answers: allows_multiple_answers,
        correct_option_id: correct_option_id,
        explanation: explanation,
        explanation_parse_mode: explanation_parse_mode,
        explanation_entities: explanation_entities,
        open_period: open_period,
        close_date: close_date,
        is_closed: is_closed,
        disable_notification: disable_notification,
        protect_content: protect_content,
        reply_to_message_id: reply_to_message_id,
        allow_sending_without_reply: allow_sending_without_reply,
        reply_markup: reply_markup,
      })
    end

    # Use this method to send an animated emoji that will display a random value. On success, the sent Message is
    # returned.
    def send_dice(
      chat_id : (Int64 | String),
      emoji : String? = nil,
      disable_notification : Bool? = nil,
      protect_content : Bool? = nil,
      reply_to_message_id : Int32? = nil,
      allow_sending_without_reply : Bool? = nil,
      reply_markup : (InlineKeyboardMarkup | ReplyKeyboardMarkup | ReplyKeyboardRemove | ForceReply)? = nil,
    )
      request(Message, "sendDice", {
        chat_id: chat_id,
        emoji: emoji,
        disable_notification: disable_notification,
        protect_content: protect_content,
        reply_to_message_id: reply_to_message_id,
        allow_sending_without_reply: allow_sending_without_reply,
        reply_markup: reply_markup,
      })
    end

    # Use this method when you need to tell the user that something is happening on the bot's side. The status is set
    # for 5 seconds or less (when a message arrives from your bot, Telegram clients clear its typing status).
    # Returns True on success. We only recommend using this method when a response from the bot will take a
    # noticeable amount of time to arrive.
    def send_chat_action(
      chat_id : (Int64 | String),
      action : String,
    )
      request(Bool, "sendChatAction", {
        chat_id: chat_id,
        action: action,
      })
    end

    # Use this method to get a list of profile pictures for a user. Returns a UserProfilePhotos object.
    def get_user_profile_photos(
      user_id : Int64,
      offset : Int32? = nil,
      limit : Int32? = nil,
    )
      request(UserProfilePhotos, "getUserProfilePhotos", {
        user_id: user_id,
        offset: offset,
        limit: limit,
      })
    end

    # Use this method to get basic info about a file and prepare it for downloading. For the moment, bots can
    # download files of up to 20MB in size. On success, a File object is returned. The file can then be downloaded
    # via the link https://api.telegram.org/file/bot<token>/<file_path>, where <file_path> is taken from
    # the response. It is guaranteed that the link will be valid for at least 1 hour. When the link expires, a new one
    # can be requested by calling getFile again. Note: This function may not preserve the original file name and
    # MIME type. You should save the file's MIME type and name (if available) when the File object is received.
    def get_file(
      file_id : String,
    )
      request(File, "getFile", {
        file_id: file_id,
      })
    end

    # Use this method to ban a user in a group, a supergroup or a channel. In the case of supergroups and channels,
    # the user will not be able to return to the chat on their own using invite links, etc., unless unbanned first.
    # The bot must be an administrator in the chat for this to work and must have the appropriate administrator
    # rights. Returns True on success.
    def ban_chat_member(
      chat_id : (Int64 | String),
      user_id : Int64,
      until_date : Int32? = nil,
      revoke_messages : Bool? = nil,
    )
      request(Bool, "banChatMember", {
        chat_id: chat_id,
        user_id: user_id,
        until_date: until_date,
        revoke_messages: revoke_messages,
      })
    end

    # Use this method to unban a previously banned user in a supergroup or channel. The user will not return to the
    # group or channel automatically, but will be able to join via link, etc. The bot must be an administrator for
    # this to work. By default, this method guarantees that after the call the user is not a member of the chat, but
    # will be able to join it. So if the user is a member of the chat they will also be removed from the chat. If you
    # don't want this, use the parameter only_if_banned. Returns True on success.
    def unban_chat_member(
      chat_id : (Int64 | String),
      user_id : Int64,
      only_if_banned : Bool? = nil,
    )
      request(Bool, "unbanChatMember", {
        chat_id: chat_id,
        user_id: user_id,
        only_if_banned: only_if_banned,
      })
    end

    # Use this method to restrict a user in a supergroup. The bot must be an administrator in the supergroup for
    # this to work and must have the appropriate administrator rights. Pass True for all permissions to lift
    # restrictions from a user. Returns True on success.
    def restrict_chat_member(
      chat_id : (Int64 | String),
      user_id : Int64,
      permissions : ChatPermissions,
      until_date : Int32? = nil,
    )
      request(Bool, "restrictChatMember", {
        chat_id: chat_id,
        user_id: user_id,
        permissions: permissions,
        until_date: until_date,
      })
    end

    # Use this method to promote or demote a user in a supergroup or a channel. The bot must be an administrator in
    # the chat for this to work and must have the appropriate administrator rights. Pass False for all boolean
    # parameters to demote a user. Returns True on success.
    def promote_chat_member(
      chat_id : (Int64 | String),
      user_id : Int64,
      is_anonymous : Bool? = nil,
      can_manage_chat : Bool? = nil,
      can_post_messages : Bool? = nil,
      can_edit_messages : Bool? = nil,
      can_delete_messages : Bool? = nil,
      can_manage_voice_chats : Bool? = nil,
      can_restrict_members : Bool? = nil,
      can_promote_members : Bool? = nil,
      can_change_info : Bool? = nil,
      can_invite_users : Bool? = nil,
      can_pin_messages : Bool? = nil,
    )
      request(Bool, "promoteChatMember", {
        chat_id: chat_id,
        user_id: user_id,
        is_anonymous: is_anonymous,
        can_manage_chat: can_manage_chat,
        can_post_messages: can_post_messages,
        can_edit_messages: can_edit_messages,
        can_delete_messages: can_delete_messages,
        can_manage_voice_chats: can_manage_voice_chats,
        can_restrict_members: can_restrict_members,
        can_promote_members: can_promote_members,
        can_change_info: can_change_info,
        can_invite_users: can_invite_users,
        can_pin_messages: can_pin_messages,
      })
    end

    # Use this method to set a custom title for an administrator in a supergroup promoted by the bot. Returns True
    # on success.
    def set_chat_administrator_custom_title(
      chat_id : (Int64 | String),
      user_id : Int64,
      custom_title : String,
    )
      request(Bool, "setChatAdministratorCustomTitle", {
        chat_id: chat_id,
        user_id: user_id,
        custom_title: custom_title,
      })
    end

    # Use this method to ban a channel chat in a supergroup or a channel. Until the chat is unbanned, the owner of the
    # banned chat won't be able to send messages on behalf of any of their channels. The bot must be an
    # administrator in the supergroup or channel for this to work and must have the appropriate administrator
    # rights. Returns True on success.
    def ban_chat_sender_chat(
      chat_id : (Int64 | String),
      sender_chat_id : Int32,
    )
      request(Bool, "banChatSenderChat", {
        chat_id: chat_id,
        sender_chat_id: sender_chat_id,
      })
    end

    # Use this method to unban a previously banned channel chat in a supergroup or channel. The bot must be an
    # administrator for this to work and must have the appropriate administrator rights. Returns True on
    # success.
    def unban_chat_sender_chat(
      chat_id : (Int64 | String),
      sender_chat_id : Int32,
    )
      request(Bool, "unbanChatSenderChat", {
        chat_id: chat_id,
        sender_chat_id: sender_chat_id,
      })
    end

    # Use this method to set default chat permissions for all members. The bot must be an administrator in the
    # group or a supergroup for this to work and must have the can_restrict_members administrator rights.
    # Returns True on success.
    def set_chat_permissions(
      chat_id : (Int64 | String),
      permissions : ChatPermissions,
    )
      request(Bool, "setChatPermissions", {
        chat_id: chat_id,
        permissions: permissions,
      })
    end

    # Use this method to generate a new primary invite link for a chat; any previously generated primary link is
    # revoked. The bot must be an administrator in the chat for this to work and must have the appropriate
    # administrator rights. Returns the new invite link as String on success.
    def export_chat_invite_link(
      chat_id : (Int64 | String),
    )
      request(String, "exportChatInviteLink", {
        chat_id: chat_id,
      })
    end

    # Use this method to create an additional invite link for a chat. The bot must be an administrator in the chat
    # for this to work and must have the appropriate administrator rights. The link can be revoked using the
    # method revokeChatInviteLink. Returns the new invite link as ChatInviteLink object.
    def create_chat_invite_link(
      chat_id : (Int64 | String),
      name : String? = nil,
      expire_date : Int32? = nil,
      member_limit : Int32? = nil,
      creates_join_request : Bool? = nil,
    )
      request(ChatInviteLink, "createChatInviteLink", {
        chat_id: chat_id,
        name: name,
        expire_date: expire_date,
        member_limit: member_limit,
        creates_join_request: creates_join_request,
      })
    end

    # Use this method to edit a non-primary invite link created by the bot. The bot must be an administrator in the
    # chat for this to work and must have the appropriate administrator rights. Returns the edited invite link as
    # a ChatInviteLink object.
    def edit_chat_invite_link(
      chat_id : (Int64 | String),
      invite_link : String,
      name : String? = nil,
      expire_date : Int32? = nil,
      member_limit : Int32? = nil,
      creates_join_request : Bool? = nil,
    )
      request(ChatInviteLink, "editChatInviteLink", {
        chat_id: chat_id,
        invite_link: invite_link,
        name: name,
        expire_date: expire_date,
        member_limit: member_limit,
        creates_join_request: creates_join_request,
      })
    end

    # Use this method to revoke an invite link created by the bot. If the primary link is revoked, a new link is
    # automatically generated. The bot must be an administrator in the chat for this to work and must have the
    # appropriate administrator rights. Returns the revoked invite link as ChatInviteLink object.
    def revoke_chat_invite_link(
      chat_id : (Int64 | String),
      invite_link : String,
    )
      request(ChatInviteLink, "revokeChatInviteLink", {
        chat_id: chat_id,
        invite_link: invite_link,
      })
    end

    # Use this method to approve a chat join request. The bot must be an administrator in the chat for this to work
    # and must have the can_invite_users administrator right. Returns True on success.
    def approve_chat_join_request(
      chat_id : (Int64 | String),
      user_id : Int64,
    )
      request(Bool, "approveChatJoinRequest", {
        chat_id: chat_id,
        user_id: user_id,
      })
    end

    # Use this method to decline a chat join request. The bot must be an administrator in the chat for this to work
    # and must have the can_invite_users administrator right. Returns True on success.
    def decline_chat_join_request(
      chat_id : (Int64 | String),
      user_id : Int64,
    )
      request(Bool, "declineChatJoinRequest", {
        chat_id: chat_id,
        user_id: user_id,
      })
    end

    # Use this method to set a new profile photo for the chat. Photos can't be changed for private chats. The bot
    # must be an administrator in the chat for this to work and must have the appropriate administrator rights.
    # Returns True on success.
    def set_chat_photo(
      chat_id : (Int64 | String),
      photo : InputFile,
    )
      request(Bool, "setChatPhoto", {
        chat_id: chat_id,
        photo: photo,
      })
    end

    # Use this method to delete a chat photo. Photos can't be changed for private chats. The bot must be an
    # administrator in the chat for this to work and must have the appropriate administrator rights. Returns
    # True on success.
    def delete_chat_photo(
      chat_id : (Int64 | String),
    )
      request(Bool, "deleteChatPhoto", {
        chat_id: chat_id,
      })
    end

    # Use this method to change the title of a chat. Titles can't be changed for private chats. The bot must be an
    # administrator in the chat for this to work and must have the appropriate administrator rights. Returns
    # True on success.
    def set_chat_title(
      chat_id : (Int64 | String),
      title : String,
    )
      request(Bool, "setChatTitle", {
        chat_id: chat_id,
        title: title,
      })
    end

    # Use this method to change the description of a group, a supergroup or a channel. The bot must be an
    # administrator in the chat for this to work and must have the appropriate administrator rights. Returns
    # True on success.
    def set_chat_description(
      chat_id : (Int64 | String),
      description : String? = nil,
    )
      request(Bool, "setChatDescription", {
        chat_id: chat_id,
        description: description,
      })
    end

    # Use this method to add a message to the list of pinned messages in a chat. If the chat is not a private chat, the
    # bot must be an administrator in the chat for this to work and must have the 'can_pin_messages'
    # administrator right in a supergroup or 'can_edit_messages' administrator right in a channel. Returns
    # True on success.
    def pin_chat_message(
      chat_id : (Int64 | String),
      message_id : Int32,
      disable_notification : Bool? = nil,
    )
      request(Bool, "pinChatMessage", {
        chat_id: chat_id,
        message_id: message_id,
        disable_notification: disable_notification,
      })
    end

    # Use this method to remove a message from the list of pinned messages in a chat. If the chat is not a private
    # chat, the bot must be an administrator in the chat for this to work and must have the 'can_pin_messages'
    # administrator right in a supergroup or 'can_edit_messages' administrator right in a channel. Returns
    # True on success.
    def unpin_chat_message(
      chat_id : (Int64 | String),
      message_id : Int32? = nil,
    )
      request(Bool, "unpinChatMessage", {
        chat_id: chat_id,
        message_id: message_id,
      })
    end

    # Use this method to clear the list of pinned messages in a chat. If the chat is not a private chat, the bot must be
    # an administrator in the chat for this to work and must have the 'can_pin_messages' administrator right in a
    # supergroup or 'can_edit_messages' administrator right in a channel. Returns True on success.
    def unpin_all_chat_messages(
      chat_id : (Int64 | String),
    )
      request(Bool, "unpinAllChatMessages", {
        chat_id: chat_id,
      })
    end

    # Use this method for your bot to leave a group, supergroup or channel. Returns True on success.
    def leave_chat(
      chat_id : (Int64 | String),
    )
      request(Bool, "leaveChat", {
        chat_id: chat_id,
      })
    end

    # Use this method to get up to date information about the chat (current name of the user for one-on-one
    # conversations, current username of a user, group or channel, etc.). Returns a Chat object on success.
    def get_chat(
      chat_id : (Int64 | String),
    )
      request(Chat, "getChat", {
        chat_id: chat_id,
      })
    end

    # Use this method to get a list of administrators in a chat. On success, returns an Array of ChatMember objects
    # that contains information about all chat administrators except other bots. If the chat is a group or a
    # supergroup and no administrators were appointed, only the creator will be returned.
    def get_chat_administrators(
      chat_id : (Int64 | String),
    )
      request(Array(ChatMember), "getChatAdministrators", {
        chat_id: chat_id,
      })
    end

    # Use this method to get the number of members in a chat. Returns Int on success.
    def get_chat_member_count(
      chat_id : (Int64 | String),
    )
      request(Int32, "getChatMemberCount", {
        chat_id: chat_id,
      })
    end

    # Use this method to get information about a member of a chat. Returns a ChatMember object on success.
    def get_chat_member(
      chat_id : (Int64 | String),
      user_id : Int64,
    )
      request(ChatMember, "getChatMember", {
        chat_id: chat_id,
        user_id: user_id,
      })
    end

    # Use this method to set a new group sticker set for a supergroup. The bot must be an administrator in the chat
    # for this to work and must have the appropriate administrator rights. Use the field can_set_sticker_set
    # optionally returned in getChat requests to check if the bot can use this method. Returns True on success.
    def set_chat_sticker_set(
      chat_id : (Int64 | String),
      sticker_set_name : String,
    )
      request(Bool, "setChatStickerSet", {
        chat_id: chat_id,
        sticker_set_name: sticker_set_name,
      })
    end

    # Use this method to delete a group sticker set from a supergroup. The bot must be an administrator in the chat
    # for this to work and must have the appropriate administrator rights. Use the field can_set_sticker_set
    # optionally returned in getChat requests to check if the bot can use this method. Returns True on success.
    def delete_chat_sticker_set(
      chat_id : (Int64 | String),
    )
      request(Bool, "deleteChatStickerSet", {
        chat_id: chat_id,
      })
    end

    # Use this method to send answers to callback queries sent from inline keyboards. The answer will be
    # displayed to the user as a notification at the top of the chat screen or as an alert. On success, True is
    # returned.
    def answer_callback_query(
      callback_query_id : String,
      text : String? = nil,
      show_alert : Bool? = nil,
      url : String? = nil,
      cache_time : Int32? = nil,
    )
      request(Bool, "answerCallbackQuery", {
        callback_query_id: callback_query_id,
        text: text,
        show_alert: show_alert,
        url: url,
        cache_time: cache_time,
      })
    end

    # Use this method to change the list of the bot's commands. See https://core.telegram.org/bots#commands
    # for more details about bot commands. Returns True on success.
    def set_my_commands(
      commands : Array(BotCommand),
      scope : BotCommandScope? = nil,
      language_code : String? = nil,
    )
      request(Bool, "setMyCommands", {
        commands: commands,
        scope: scope,
        language_code: language_code,
      })
    end

    # Use this method to delete the list of the bot's commands for the given scope and user language. After
    # deletion, higher level commands will be shown to affected users. Returns True on success.
    def delete_my_commands(
      scope : BotCommandScope? = nil,
      language_code : String? = nil,
    )
      request(Bool, "deleteMyCommands", {
        scope: scope,
        language_code: language_code,
      })
    end

    # Use this method to get the current list of the bot's commands for the given scope and user language. Returns
    # Array of BotCommand on success. If commands aren't set, an empty list is returned.
    def get_my_commands(
      scope : BotCommandScope? = nil,
      language_code : String? = nil,
    )
      request(Array(BotCommand), "getMyCommands", {
        scope: scope,
        language_code: language_code,
      })
    end

    # Use this method to edit text and game messages. On success, if the edited message is not an inline message,
    # the edited Message is returned, otherwise True is returned.
    def edit_message_text(
      text : String,
      chat_id : (Int64 | String)? = nil,
      message_id : Int32? = nil,
      inline_message_id : String? = nil,
      parse_mode : ParseMode? = nil,
      disable_web_page_preview : Bool? = nil,
      reply_markup : InlineKeyboardMarkup? = nil,
      entities : Array(MessageEntity)? = nil,
    )
      request((Message | Bool), "editMessageText", {
        chat_id: chat_id,
        message_id: message_id,
        inline_message_id: inline_message_id,
        text: text,
        parse_mode: parse_mode,
        entities: entities,
        disable_web_page_preview: disable_web_page_preview,
        reply_markup: reply_markup,
      })
    end

    # Use this method to edit captions of messages. On success, if the edited message is not an inline message, the
    # edited Message is returned, otherwise True is returned.
    def edit_message_caption(
      chat_id : (Int64 | String)? = nil,
      message_id : Int32? = nil,
      inline_message_id : String? = nil,
      caption : String? = nil,
      parse_mode : ParseMode? = nil,
      reply_markup : InlineKeyboardMarkup? = nil,
      caption_entities : Array(MessageEntity)? = nil,
    )
      request((Message | Bool), "editMessageCaption", {
        chat_id: chat_id,
        message_id: message_id,
        inline_message_id: inline_message_id,
        caption: caption,
        parse_mode: parse_mode,
        caption_entities: caption_entities,
        reply_markup: reply_markup,
      })
    end

    # Use this method to edit animation, audio, document, photo, or video messages. If a message is part of a
    # message album, then it can be edited only to an audio for audio albums, only to a document for document albums
    # and to a photo or a video otherwise. When an inline message is edited, a new file can't be uploaded; use a
    # previously uploaded file via its file_id or specify a URL. On success, if the edited message is not an inline
    # message, the edited Message is returned, otherwise True is returned.
    def edit_message_media(
      media : InputMedia,
      chat_id : (Int64 | String)? = nil,
      message_id : Int32? = nil,
      inline_message_id : String? = nil,
      reply_markup : InlineKeyboardMarkup? = nil,
    )
      request((Message | Bool), "editMessageMedia", {
        chat_id: chat_id,
        message_id: message_id,
        inline_message_id: inline_message_id,
        media: media,
        reply_markup: reply_markup,
      })
    end

    # Use this method to edit only the reply markup of messages. On success, if the edited message is not an inline
    # message, the edited Message is returned, otherwise True is returned.
    def edit_message_reply_markup(
      chat_id : (Int64 | String)? = nil,
      message_id : Int32? = nil,
      inline_message_id : String? = nil,
      reply_markup : InlineKeyboardMarkup? = nil,
    )
      request((Message | Bool), "editMessageReplyMarkup", {
        chat_id: chat_id,
        message_id: message_id,
        inline_message_id: inline_message_id,
        reply_markup: reply_markup,
      })
    end

    # Use this method to stop a poll which was sent by the bot. On success, the stopped Poll is returned.
    def stop_poll(
      chat_id : (Int64 | String),
      message_id : Int32,
      reply_markup : InlineKeyboardMarkup? = nil,
    )
      request(Poll, "stopPoll", {
        chat_id: chat_id,
        message_id: message_id,
        reply_markup: reply_markup,
      })
    end

    # Use this method to delete a message, including service messages, with the following limitations:- A
    # message can only be deleted if it was sent less than 48 hours ago.- A dice message in a private chat can only be
    # deleted if it was sent more than 24 hours ago.- Bots can delete outgoing messages in private chats, groups,
    # and supergroups.- Bots can delete incoming messages in private chats.- Bots granted can_post_messages
    # permissions can delete outgoing messages in channels.- If the bot is an administrator of a group, it can
    # delete any message there.- If the bot has can_delete_messages permission in a supergroup or a channel, it
    # can delete any message there.Returns True on success.
    def delete_message(
      chat_id : (Int64 | String),
      message_id : Int32,
    )
      request(Bool, "deleteMessage", {
        chat_id: chat_id,
        message_id: message_id,
      })
    end

    # Use this method to send static .WEBP or animated .TGS stickers. On success, the sent Message is returned.
    def send_sticker(
      chat_id : (Int64 | String),
      sticker : (InputFile | String),
      disable_notification : Bool? = nil,
      protect_content : Bool? = nil,
      reply_to_message_id : Int32? = nil,
      allow_sending_without_reply : Bool? = nil,
      reply_markup : (InlineKeyboardMarkup | ReplyKeyboardMarkup | ReplyKeyboardRemove | ForceReply)? = nil,
    )
      request(Message, "sendSticker", {
        chat_id: chat_id,
        sticker: sticker,
        disable_notification: disable_notification,
        protect_content: protect_content,
        reply_to_message_id: reply_to_message_id,
        allow_sending_without_reply: allow_sending_without_reply,
        reply_markup: reply_markup,
      })
    end

    # Use this method to get a sticker set. On success, a StickerSet object is returned.
    def get_sticker_set(
      name : String,
    )
      request(StickerSet, "getStickerSet", {
        name: name,
      })
    end

    # Use this method to upload a .PNG file with a sticker for later use in createNewStickerSet and
    # addStickerToSet methods (can be used multiple times). Returns the uploaded File on success.
    def upload_sticker_file(
      user_id : Int64,
      png_sticker : InputFile,
    )
      request(File, "uploadStickerFile", {
        user_id: user_id,
        png_sticker: png_sticker,
      })
    end

    # Use this method to create a new sticker set owned by a user. The bot will be able to edit the sticker set thus
    # created. You must use exactly one of the fields png_sticker or tgs_sticker. Returns True on success.
    def create_new_sticker_set(
      user_id : Int64,
      name : String,
      title : String,
      emojis : String,
      png_sticker : (InputFile | String)? = nil,
      tgs_sticker : InputFile? = nil,
      contains_masks : Bool? = nil,
      mask_position : MaskPosition? = nil,
    )
      request(Bool, "createNewStickerSet", {
        user_id: user_id,
        name: name,
        title: title,
        png_sticker: png_sticker,
        tgs_sticker: tgs_sticker,
        emojis: emojis,
        contains_masks: contains_masks,
        mask_position: mask_position,
      })
    end

    # Use this method to add a new sticker to a set created by the bot. You must use exactly one of the fields
    # png_sticker or tgs_sticker. Animated stickers can be added to animated sticker sets and only to them.
    # Animated sticker sets can have up to 50 stickers. Static sticker sets can have up to 120 stickers. Returns
    # True on success.
    def add_sticker_to_set(
      user_id : Int64,
      name : String,
      emojis : String,
      png_sticker : (InputFile | String)? = nil,
      tgs_sticker : InputFile? = nil,
      mask_position : MaskPosition? = nil,
    )
      request(Bool, "addStickerToSet", {
        user_id: user_id,
        name: name,
        png_sticker: png_sticker,
        tgs_sticker: tgs_sticker,
        emojis: emojis,
        mask_position: mask_position,
      })
    end

    # Use this method to move a sticker in a set created by the bot to a specific position. Returns True on success.
    def set_sticker_position_in_set(
      sticker : String,
      position : Int32,
    )
      request(Bool, "setStickerPositionInSet", {
        sticker: sticker,
        position: position,
      })
    end

    # Use this method to delete a sticker from a set created by the bot. Returns True on success.
    def delete_sticker_from_set(
      sticker : String,
    )
      request(Bool, "deleteStickerFromSet", {
        sticker: sticker,
      })
    end

    # Use this method to set the thumbnail of a sticker set. Animated thumbnails can be set for animated sticker
    # sets only. Returns True on success.
    def set_sticker_set_thumb(
      name : String,
      user_id : Int64,
      thumb : (InputFile | String)? = nil,
    )
      request(Bool, "setStickerSetThumb", {
        name: name,
        user_id: user_id,
        thumb: thumb,
      })
    end

    # Use this method to send answers to an inline query. On success, True is returned.No more than 50 results per
    # query are allowed.
    def answer_inline_query(
      inline_query_id : String,
      results : Array(InlineQueryResult),
      cache_time : Int32? = nil,
      is_personal : Bool? = nil,
      next_offset : String? = nil,
      switch_pm_text : String? = nil,
      switch_pm_parameter : String? = nil,
    )
      request(Bool, "answerInlineQuery", {
        inline_query_id: inline_query_id,
        results: results,
        cache_time: cache_time,
        is_personal: is_personal,
        next_offset: next_offset,
        switch_pm_text: switch_pm_text,
        switch_pm_parameter: switch_pm_parameter,
      })
    end

    # Use this method to send invoices. On success, the sent Message is returned.
    def send_invoice(
      chat_id : (Int64 | String),
      title : String,
      description : String,
      payload : String,
      provider_token : String,
      currency : String,
      prices : Array(LabeledPrice),
      max_tip_amount : Int32? = nil,
      start_parameter : String? = nil,
      provider_data : String? = nil,
      photo_url : String? = nil,
      photo_size : Int32? = nil,
      photo_width : Int32? = nil,
      photo_height : Int32? = nil,
      need_name : Bool? = nil,
      need_phone_number : Bool? = nil,
      need_email : Bool? = nil,
      need_shipping_address : Bool? = nil,
      send_phone_number_to_provider : Bool? = nil,
      send_email_to_provider : Bool? = nil,
      is_flexible : Bool? = nil,
      disable_notification : Bool? = nil,
      protect_content : Bool? = nil,
      reply_to_message_id : Int32? = nil,
      allow_sending_without_reply : Bool? = nil,
      reply_markup : InlineKeyboardMarkup? = nil,
      suggested_tip_amounts : Array(Int32)? = nil,
    )
      request(Message, "sendInvoice", {
        chat_id: chat_id,
        title: title,
        description: description,
        payload: payload,
        provider_token: provider_token,
        currency: currency,
        prices: prices,
        max_tip_amount: max_tip_amount,
        suggested_tip_amounts: suggested_tip_amounts,
        start_parameter: start_parameter,
        provider_data: provider_data,
        photo_url: photo_url,
        photo_size: photo_size,
        photo_width: photo_width,
        photo_height: photo_height,
        need_name: need_name,
        need_phone_number: need_phone_number,
        need_email: need_email,
        need_shipping_address: need_shipping_address,
        send_phone_number_to_provider: send_phone_number_to_provider,
        send_email_to_provider: send_email_to_provider,
        is_flexible: is_flexible,
        disable_notification: disable_notification,
        protect_content: protect_content,
        reply_to_message_id: reply_to_message_id,
        allow_sending_without_reply: allow_sending_without_reply,
        reply_markup: reply_markup,
      })
    end

    # If you sent an invoice requesting a shipping address and the parameter is_flexible was specified, the Bot
    # API will send an Update with a shipping_query field to the bot. Use this method to reply to shipping queries.
    # On success, True is returned.
    def answer_shipping_query(
      shipping_query_id : String,
      ok : Bool,
      error_message : String? = nil,
      shipping_options : Array(ShippingOption)? = nil,
    )
      request(Bool, "answerShippingQuery", {
        shipping_query_id: shipping_query_id,
        ok: ok,
        shipping_options: shipping_options,
        error_message: error_message,
      })
    end

    # Once the user has confirmed their payment and shipping details, the Bot API sends the final confirmation in
    # the form of an Update with the field pre_checkout_query. Use this method to respond to such pre-checkout
    # queries. On success, True is returned. Note: The Bot API must receive an answer within 10 seconds after the
    # pre-checkout query was sent.
    def answer_pre_checkout_query(
      pre_checkout_query_id : String,
      ok : Bool,
      error_message : String? = nil,
    )
      request(Bool, "answerPreCheckoutQuery", {
        pre_checkout_query_id: pre_checkout_query_id,
        ok: ok,
        error_message: error_message,
      })
    end

    # Informs a user that some of the Telegram Passport elements they provided contains errors. The user will not
    # be able to re-submit their Passport to you until the errors are fixed (the contents of the field for which you
    # returned the error must change). Returns True on success. Use this if the data submitted by the user doesn't
    # satisfy the standards your service requires for any reason. For example, if a birthday date seems invalid,
    # a submitted document is blurry, a scan shows evidence of tampering, etc. Supply some details in the error
    # message to make sure the user knows how to correct the issues.
    def set_passport_data_errors(
      user_id : Int64,
      errors : Array(PassportElementError),
    )
      request(Bool, "setPassportDataErrors", {
        user_id: user_id,
        errors: errors,
      })
    end

    # Use this method to send a game. On success, the sent Message is returned.
    def send_game(
      chat_id : Int64,
      game_short_name : String,
      disable_notification : Bool? = nil,
      protect_content : Bool? = nil,
      reply_to_message_id : Int32? = nil,
      allow_sending_without_reply : Bool? = nil,
      reply_markup : InlineKeyboardMarkup? = nil,
    )
      request(Message, "sendGame", {
        chat_id: chat_id,
        game_short_name: game_short_name,
        disable_notification: disable_notification,
        protect_content: protect_content,
        reply_to_message_id: reply_to_message_id,
        allow_sending_without_reply: allow_sending_without_reply,
        reply_markup: reply_markup,
      })
    end

    # Use this method to set the score of the specified user in a game message. On success, if the message is not an
    # inline message, the Message is returned, otherwise True is returned. Returns an error, if the new score is
    # not greater than the user's current score in the chat and force is False.
    def set_game_score(
      user_id : Int64,
      score : Int32,
      force : Bool? = nil,
      disable_edit_message : Bool? = nil,
      chat_id : Int64? = nil,
      message_id : Int32? = nil,
      inline_message_id : String? = nil,
    )
      request((Message | Bool), "setGameScore", {
        user_id: user_id,
        score: score,
        force: force,
        disable_edit_message: disable_edit_message,
        chat_id: chat_id,
        message_id: message_id,
        inline_message_id: inline_message_id,
      })
    end

    # Use this method to get data for high score tables. Will return the score of the specified user and several of
    # their neighbors in a game. On success, returns an Array of GameHighScore objects.
    def get_game_high_scores(
      user_id : Int64,
      chat_id : Int64? = nil,
      message_id : Int32? = nil,
      inline_message_id : String? = nil,
    )
      request(Array(GameHighScore), "getGameHighScores", {
        user_id: user_id,
        chat_id: chat_id,
        message_id: message_id,
        inline_message_id: inline_message_id,
      })
    end

end